import { aws_lambda as Lambda, aws_dynamodb, aws_ssm as SSM, RemovalPolicy, Duration } from 'aws-cdk-lib';
import { Alarm } from 'aws-cdk-lib/aws-cloudwatch';
import { Role } from 'aws-cdk-lib/aws-iam';
import { FilterPattern, IFilterPattern, MetricFilter, RetentionDays } from 'aws-cdk-lib/aws-logs';
import { Construct } from 'constructs';
import { LambdaReadOnlyPolicy } from './iam/lambda-readonly-policy';
import { Statics } from './statics';

export interface ApiFunctionProps {
  description: string;
  table: aws_dynamodb.ITable;
  tablePermissions: string;
  applicationUrlBase?: string;
  environment?: {[key: string]: string};
  monitorFilterPattern?: IFilterPattern;
  readOnlyRole?: Role;
  logRetention?: RetentionDays;
  ssmLogGroup?: string;
  lambdaInsightsExtensionArn: string;
}

export class ApiFunction<T extends Lambda.Function> extends Construct {

  lambda: T;

  constructor(
    scope: Construct,
    id: string,
    props: ApiFunctionProps,
    apiFunction: {new(scope2: Construct, id2:string, props2?: Lambda.FunctionProps): T},
  ) {
    super(scope, id);
    const retention = props.logRetention ? props.logRetention : RetentionDays.ONE_MONTH;
    this.lambda = new apiFunction(this, 'lambda', {
      runtime: Lambda.Runtime.NODEJS_14_X, // Overwritten
      code: Lambda.Code.fromInline('empty'), // Overwritten
      handler: 'index.handler', // Overwritten by apiFunction constructor
      memorySize: 512,
      description: props.description,
      insightsVersion: Lambda.LambdaInsightsVersion.fromInsightVersionArn(props.lambdaInsightsExtensionArn),
      logRetention: retention,
      environment: {
        APPLICATION_URL_BASE: props.applicationUrlBase || '',
        SESSION_TABLE: props.table.tableName,
        ...props.environment,
      },
    });

    props.table.grantReadWriteData(this.lambda.grantPrincipal);

    if (props.ssmLogGroup) { // Export the loggroup to an ssm parameter
      new SSM.StringParameter(this, 'log-group-ssm', {
        parameterName: props.ssmLogGroup,
        stringValue: this.lambda.logGroup.logGroupName,
      });
    }

    this.monitor(props.monitorFilterPattern);
    if(props.readOnlyRole){
      this.allowAccessToReadOnlyRole(props.readOnlyRole);
    }
  }

  /**
   * Monitor the logs generated by this function for a filter pattern, generate metric
   * and alarm on increased error rate.
   *
   * @param monitoredBy Lambda function responsible for monitoring this function
   * @param filterPattern Pattern to filter by (default: containing ERROR)
   */
  private monitor(filterPattern?: IFilterPattern) {
    const errorMetricFilter = new MetricFilter(this, 'MetricFilter', {
      logGroup: this.lambda.logGroup,
      metricNamespace: `${Statics.projectName}/${this.node.id}`,
      metricName: 'Errors',
      filterPattern: filterPattern ?? FilterPattern.anyTerm('ERROR'),
      metricValue: '1',
    });
    errorMetricFilter.applyRemovalPolicy(RemovalPolicy.DESTROY);

    const alarm = new Alarm(this, `${Statics.projectName}-${this.node.id}-alarm`, {
      metric: errorMetricFilter.metric({
        statistic: 'sum',
        period: Duration.minutes(5),
      }),
      evaluationPeriods: 3,
      threshold: 5,
      alarmName: `Increased error rate for ${this.node.id}`,
      alarmDescription: `This alarm triggers if the function ${this.node.id} is logging more than 5 errors over n minutes.`,
    });
    alarm.applyRemovalPolicy(RemovalPolicy.DESTROY);
  }

  private allowAccessToReadOnlyRole(role: Role) {
    role.addManagedPolicy(
      new LambdaReadOnlyPolicy(this, 'read-policy', {
        functionArn: this.lambda.functionArn,
        logGroupArn: this.lambda.logGroup.logGroupArn,
      }),
    );
  }
}
